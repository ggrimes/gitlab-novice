---
title: "Recording Changes Locally"
teaching: 20
exercises: 5
---

::: questions
-   How do I create a new Git repository for my project?
-   How do I check which files have been modified?
-   How do I record a snapshot of my work?
-   How can I review what has changed between versions?
:::

::: objectives
-   Initialise a repository with `git init`.
-   Explain the roles of the **working directory**, **staging area**, and **repository**.
-   Track new or modified files with `git add` and record them with `git commit`.
-   Use `git status` to see the state of the working directory and staging area.
-   Compare changes with `git diff` and inspect history with `git log`.
-   Restore a file to an earlier state with `git restore` (or `git checkout --` for older Git versions).
:::

## Introduction

With Git configured, we can start **tracking changes**. Think of Git as a camera: every time you take a *commit* you capture a snapshot of the files that are *staged*. Much like arranging subjects before pressing the shutter, you choose *what* to record with `git add`.

Three locations matter (see diagram below):

1.  **Working directory** – files you edit in your editor/IDE.
2.  **Staging area** – a holding zone for the next snapshot.
3.  **Repository** – the permanent, time‑stamped history.

![](https://swcarpentry.github.io/git-novice/fig/git-staging-area.svg){alt="Flow diagram from working directory to staging area to repository."}

::: instructor
Some learners struggle with the staging area at first. Compare it to packing items into a box (staging) before placing the box in long‑term storage (repository). Running `git status` after every major step reinforces the mental model.
:::

### 1. Create a repository

``` bash
$ mkdir MyProject
$ cd MyProject
$ git init            # creates .git directory
```

`git init` creates a hidden `.git` folder that stores all future history.

:::: challenge
#### Challenge 1: First contact

Run `git status` immediately after `git init`. What output do you see and why?

::: solution
Git reports

``` text
On branch main (or master)

No commits yet
nothing to commit (create/copy files and use "git add" to track)
```

because we have not created any files or commits; the repository is empty.
:::
::::

### 2. Add a README file

``` bash
$ echo "# My eddie Python project" > README.md
$ git status          # untracked file appears in red
$ git add README.md   # stage the file
$ git status          # file appears in green (staged)
```

Staging tells Git *which* changes belong to the next snapshot.

### 3. Commit the snapshot

``` bash
$ git commit -m "Add README with project title"
[main 23bd868] Add README with project title
 1 file changed, 1 insertion(+)
 create mode 100644 README.md
```

Every commit receives a unique 40‑character *hash* (displayed here as **23bd868** for brevity).

:::: challenge
#### Challenge 2: Where is my commit?

Use `git log --oneline` to view the history. How many commits appear and what information is shown?

::: solution
One commit appears:

``` text
23bd868 (HEAD -> main) Add README with project title
```

We see the abbreviated hash, the branch name, and the commit message.
:::
::::

### 4. Modifying a file

Edit *README.md* 

```bash
nano README.md
```

add a *Run Script* section

```
# My eddie Python project​

To run Python on eddie need to run:​
    module load igmm/apps/python/3.7
```

stage the file using `git add`

```bash
git add README.md
```


``` bash
$ git status          # modified file in red
$ git diff README.md  # view changes
```

Lines removed are prefixed with `-` (red); additions with `+` (green).

Stage and commit the update:

``` bash
$ git add README.md
$ git commit -m "Describe how to run analysis script"
```

### 5. Inspecting differences between commits

``` bash
$ git diff HEAD~1 README.md   # compare current commit to one before
```

`HEAD` is a symbolic name for *the current commit*; `HEAD~1` means *one commit ago*.

:::: challenge
#### Challenge 3: Predict the diff

Suppose the original README contained only a title. After adding a section called **Data**, what colour will the new lines appear in the diff output and why?

::: solution
They will be **green with a + prefix** because new lines are *additions* relative to the previous snapshot.
:::
::::

### 6. Undoing a change in the working directory

You can discard **unstaged** edits:

``` bash
$ git restore README.md   # newer Git (>=2.23)
# or
$ git checkout -- README.md  # older Git versions
```

Be cautious: this removes changes **permanently** unless they were staged or committed.

### 7. Adding directories and data

Git tracks **files**, not empty directories. To include a folder you must add at least one file inside it (often an empty `.gitkeep`):

``` bash
$ mkdir Src
$ touch Src/.gitkeep
$ git add Src/.gitkeep
```

For data files:

``` bash
$ mkdir Data
$ curl -L -o Data/data.csv https://figshare.com/ndownloader/files/14632895
$ git add Data/data.csv # Comment on when to commit data​
$ git commit -m "Add example dataset"
```

:::: challenge
#### Challenge 4: Multiple file workflow

Create a simple Python script *Src/hello.py* that prints *"Hello World!"*. Add and commit it. Then modify the script to read the CSV file added above and print the number of rows. Use `git diff` before committing to verify the change.

::: solution
1.  Create the file:

    ``` python
        #!/usr/bin/env python
        print("Hello World!")
    ```

    ``` bash
    $ git add Src/hello.py
    $ git commit -m "Add hello world script"
    ```

2.  Edit the script, stage, inspect, commit:

    ``` python
    #!/usr/bin/env python​
    ​
    # load pandas library​
    import pandas as pd​
    ​
    # Read the data​
    variants =  pd.read_csv("Data/data.csv")​
    ​
    # Check we have the data​
    print(variants)
    ```

    ``` bash
    $ git diff Src/hello.py   # shows additions
    $ git add Src/hello.py
    $ git commit -m "Read CSV and report row count"
    ```
:::
::::

### 8. Viewing the complete history

``` bash
$ git log --graph --oneline --decorate --all
```

The `--graph` flag draws an ASCII branch diagram; `--decorate` shows branch names.

::: keypoints
-   `git init` turns a directory into a repository by creating `.git`.
-   `git status` is your friend—run it often.
-   Stage files with `git add`; record them permanently with `git commit -m`.
-   Use `git diff` to inspect unstaged or staged changes.
-   `git log` reveals the history; hashes uniquely identify commits.
-   Empty directories are **not tracked**—add a file such as `.gitkeep`.
-   `git restore` (or `git checkout --`) returns a file to a known state.
:::
